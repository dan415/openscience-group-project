<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main" xml:id="_XzAvaSW">Church: a language for generative models</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName coords="1,198.12,154.92,95.19,8.77;1,293.30,153.37,1.36,6.12"><forename type="first">Noah</forename><forename type="middle">D</forename><surname>Goodman</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT BCS/CSAIL Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,301.06,154.92,113.47,8.77;1,414.52,153.37,1.36,6.12"><forename type="first">Vikash</forename><forename type="middle">K</forename><surname>Mansinghka</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT BCS/CSAIL Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,171.88,166.87,52.86,8.77"><forename type="first">Daniel</forename><surname>Roy</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT BCS/CSAIL Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,234.13,166.87,78.55,8.77"><forename type="first">Keith</forename><surname>Bonawitz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT BCS/CSAIL Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName coords="1,329.23,166.87,110.90,8.77"><forename type="first">Joshua</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">MIT BCS/CSAIL Cambridge</orgName>
								<address>
									<postCode>02139</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main" xml:id="_4YNq4Wp">Church: a language for generative models</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">C27B2F57FC5E32ACBE967F78A13AF57F</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-05-12T20:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0" xml:id="_MfEPYyd"><p xml:id="_vyxnhaC">Formal languages for probabilistic modeling enable re-use, modularity, and descriptive clarity, and can foster generic inference techniques. We introduce Church, a universal language for describing stochastic generative processes. Church is based on the Lisp model of lambda calculus, containing a pure Lisp as its deterministic subset. The semantics of Church is defined in terms of evaluation histories and conditional distributions on such histories. Church also includes a novel language construct, the stochastic memoizer, which enables simple description of many complex non-parametric models. We illustrate language features through several examples, including: a generalized Bayes net in which parameters cluster over trials, infinite PCFGs, planning by inference, and various non-parametric clustering models. Finally, we show how to implement query on any Church program, exactly and approximately, using Monte Carlo techniques.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<facsimile>
		<surface n="1" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="2" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="3" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="4" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="5" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="6" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="7" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="8" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="9" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
		<surface n="10" ulx="0.0" uly="0.0" lrx="612.0" lry="792.0"/>
	</facsimile>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1" xml:id="_n479JQc">INTRODUCTION</head><p xml:id="_6fxUMZ7">Probabilistic models have proven to be an enormously useful tool in artificial intelligence, machine learning, and cognitive science. Most often these models are specified in a combination of natural and mathematical language, and inference for each new model is implemented by hand. Stochastic programming languages [e.g. <ref type="bibr" coords="1,115.02,655.23,12.68,8.74" target="#b11">12,</ref><ref type="bibr" coords="1,130.71,655.23,12.68,8.74" target="#b13">14,</ref><ref type="bibr" coords="1,146.40,655.23,12.68,8.74" target="#b9">10]</ref> aim to tame the model-building process by giving a formal language which provides simple, uniform, and re-usable descriptions of a wide class of models, and supports generic inference techniques. In this paper we present the Church stochastic * The first two authors contributed equally to this work.</p><p xml:id="_SxX6ETQ">programming language (named for computation pioneer Alonzo Church), a universal language for describing generative processes and conditional queries over them. Because this language is based on Church's lambda calculus, expressions, which represent generative models, may be arbitrarily composed and abstracted. The distinctive features of Church, and the main contributions of this paper, are: 1) a Lisp-like language specification in which we view evaluation as sampling and query as conditional sampling, 2) a stochastic memoizer, which allows separate evaluations to share generative history and enables easy description of non-parametric probabilistic models, and, 3) generic schemes for exact and approximate inference, which implement the query primitive, so that any Church program may be run without writing specialpurpose inference code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2" xml:id="_C7T3Xhe">THE CHURCH LANGUAGE</head><p xml:id="_VygBPpy">The Church language is based upon a pure subset of the functional language Scheme <ref type="bibr" coords="1,470.72,491.72,10.09,8.74" target="#b5">[6]</ref>, a Lisp dialect. Church is a dynamically-typed, applicative-order language, in which procedures are first-class and expressions are values. Church expressions describe generative processes: the meaning of an expression is specified through a primitive procedure eval, which samples from the process, and a primitive procedure query, which generalizes eval to sample conditionally. In true Lisp spirit, eval and query are ordinary procedures that may be nested within a Church program. Randomness is introduced through stochastic primitive functions; memoization allows random computations to be reused. Here x stands for a variable (from a countable set of arXiv:1206.3255v2 [cs.PL] 15 Jul 2014 variable symbols), e i for expressions, and c for a (primitive) constant. (We often write 'e as shorthand for (quote e).)</p><p xml:id="_rUjznzx">The constants include primitive data types (nil, Boolean, char, integer, fixed-precision real, etc.), and standard functions to build data structures (notably pair, first, and rest for lists) and manipulate basic types (e.g. and, not) 1 . As in most programming languages, all primitive types are countable; real numbers are approximated by either fixed-or floating-precision arithmetic. A number of standard (deterministic) functions, such as the higher-order function map, are provided as a standard library, automatically defined in the global environment. Other standard Scheme constructs are provided-such as (let ((a a-def ) (b b-def ) ...) body), which introduces names that can be used in body, and is sugar for nested lambdas.</p><p xml:id="_fTEyFP8">Church values include Church expressions, and procedures; if v 1 ...v n are Church values the list (v 1 ...v n ) is a Church value. A Church environment is a list of pairs consisting of a variable symbol and a value (the variable is bound to the value); note that an environment is a Church value. Procedures come in two types: Ordinary procedures are triples, (body, args, env), of a Church expression (the body), a list of variable symbols (the formal parameters, or arguments), and an environment. Elementary random procedures are ordinary procedures that also have a distribution function-a probability function that reports the probability P ( value | env, args) of a return value from evaluating the body (via the eval procedure described below) given env and values of the formal parameters 2 .</p><p xml:id="_P28EzEt">To provide an initial set of elementary random procedures we allow stochastic primitive functions, in addition to the usual constants, that randomly sample a return value depending only on the current environment. Unlike other constants, these random functions are available only wrapped into elementary random procedures: (fun, args, env, dist), where dist = P ( value | env, args) is the probability function for fun. We include several elementary random procedures, such as flip which flips a fair coin (or flips a weighted coin when called with a weight argument). 1 The primitive function gensym deserves special note: (eval '(gensym) env) returns a procedure (c, x, env) where c is a constant function which returns True if x is bound to the procedure (c, x, env), and False otherwise. Furthermore it is guaranteed that (gensym (gensym)) evaluates to False (i.e. each evaluation of gensym results in a unique value).</p><p xml:id="_yhFe8qx">2 This definition implies that when the body of an elementary random procedure is not a constant, its distribution function represents the marginal probability over any other random choices made in evaluating the body. This becomes important for implementing query.</p><p xml:id="_gUE7BRF">A Church expression defines a generative process via the recursive evaluation procedure, eval. This primitive procedure takes an expression and an environment and returns a value-it is an environment model, shared with Scheme, of Church's lambda calculus <ref type="bibr" coords="2,315.00,125.03,10.63,8.74" target="#b3">[4,</ref><ref type="bibr" coords="2,329.61,125.03,7.08,8.74" target="#b5">6]</ref>. The evaluation rules are given in Fig. <ref type="figure" coords="2,521.03,125.03,3.95,8.74">1</ref>. An evaluation history for an expression e is the sequence of recursive calls to eval, and their return values, made by (eval 'e env). The probability of a finite evaluation history is the product of the probabilities for each elementary random procedure evaluation in this history <ref type="foot" coords="2,345.85,195.19,3.97,6.12" target="#foot_0">3</ref> . The weight of an expression in a particular environment is the sum of the probabilities of all of its finite evaluation histories. An expression is admissible in an environment if it has weight one, and a procedure is admissible if its body is admissible in its environment for all values of its arguments. An admissible expression defines a distribution on evaluation histories (we make this claim precise in section 2.2). Note that an admissible expression can have infinite histories, but the set of infinite histories must have probability zero. Thus admissibility can be thought of as the requirement that evaluation of an expression halts with probability one. Marginalizing this distribution over histories results in a distribution on values, which we write µ(e, env). Thus, (eval 'e env), for admissible e, returns a sample from µ(e, env).</p><p xml:id="_3maAt6d">The procedure eval allows us to interpret Church as a language for generative processes, but for useful probabilistic inference we must be able to sample from a distribution conditioned on some assertions (for instance the posterior probability of a hypothesis conditioned on observed data). The procedure (query 'e p env) is defined to be a procedure which samples a value from µ(e, env) conditioned on the predicate procedure p returning True when applied to the value of (eval 'e env). The environment argument env is optional, defaulting to the current environment. (Note that the special case of query when the predicate p is the constant procedure (lambda (x) True) defines the same distribution on values as eval.) For example, one might write (query '(pair (flip) (flip)) (lambda (v) (+ (first v) (last v)))) to describe the conditional distribution of two flips given that at least one flip landed heads. If e or p are not admissible in env the query result is undefined. We describe this conditional distribution, and conditions for its welldefinedness, more formally in Theorem 2.3. In Section 4 we consider Monte Carlo techniques for implementing query.</p><p xml:id="_8h8H9A4">• (eval 'c env): For constant c, return c(env).</p><p xml:id="_sWYYva2">• (eval 'x env): Look-up symbol x in env, return the value it is bound to.</p><p xml:id="_YvZhUea">• (eval '(e1 e2 ...) env): Evaluate each (eval 'ei env). The value of (eval 'e1 env) should be a procedure (body, x2 ..., env2). Make env3 by extending env2, binding x2 ... to the return values of e2 .... Return the value of (eval body env3).</p><p xml:id="_PvmMUma">• (eval '(lambda (x...) e) env): Return the procedure (e, x..., env).</p><p xml:id="_WyxVUKY">• (eval '(if e1 e2 e3) env): If (eval e1 env) returns True return the return value of (eval e2 env), otherwise of (eval e3 env).</p><p xml:id="_Yz6C6R4">• (eval '(quote e) env): Return the expression e (as a value).</p><p xml:id="_F8WtuUU">• (eval '(define x e) env): Extend env by binding the value of (eval 'e env) to x; return the extended environment.</p><p xml:id="_CuCbx29">Figure <ref type="figure" coords="3,92.43,291.84,3.58,7.86">1</ref>: An informal definition of the eval procedure. If preconditions of these descriptions fail the constant value error is returned. Note that constants represent (possibly stochastic) functions from environments to values-truly "constant" constants return themselves.</p><p xml:id="_Ubfuu9A">It can be awkward in practice to write programs using query, because many random values must be explicitly passed from the query expression to the predicate through the return value. An alternative is to provide a means to name random values which are shared by all evaluations, building up a "random world" within the query. To enable a this style of programming, we provide the procedure lex-query (for "lexicalizing query") which has the form:</p><formula xml:id="formula_0" coords="3,63.38,481.69,93.80,55.51">(lex-query '((A A-definition) (B B-definition) ...) 'e 'p)</formula><p xml:id="_GsS64HC">where the first argument binds a lexicon of symbols to definitions, which are available in the environment in which the remaining (query and predicate) expressions are evaluated. In this form the predicate is an expression, and the final environment argument is omittedthe current environment is used.</p><p xml:id="_RTB2ZH4">A program in Church consists of a sequence of Church expressions-this sequence is called the top level. Any definitions at the top level are treated as extending the global (i.e. initial) environment, which then is used to evaluate the remaining top-level expressions. For instance:</p><formula xml:id="formula_1" coords="3,62.91,699.86,72.86,8.12">(define A e1) e2</formula><p xml:id="_PvSgxkQ">is treated as:</p><p xml:id="_TpyjKRD">(eval 'e2 (eval '(define A e1) global-env)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1" xml:id="_SBgAtYa">Stochastic Memoization</head><p xml:id="_fNfpZDK">In deterministic computation, memoization is a technique for efficient implementation that does not affect the language semantics: the first time a (purely functional) procedure is evaluated with given arguments its return value is recorded; thereafter evaluations of that procedure with those arguments directly return this value, without re-evaluating the procedure body. Memoization of a stochastic program can radically change the semantics: if flip is an ordinary random procedure (= (flip) (flip)) is True with probability 0.5, but if flip is memoized this expression is True with probability one. More generally, a collection of memoized functions has a random-world semantics as discussed in <ref type="bibr" coords="3,372.82,242.32,14.74,8.74" target="#b9">[10]</ref>. In Section 3 we use memoization together with lex-query to describe generative processes involving an unknown number of objects with persistent features, similar to the BLOG language <ref type="bibr" coords="3,532.46,278.18,14.48,8.74" target="#b11">[12]</ref>.</p><p xml:id="_pK668jG">To formally define memoization in Church, we imagine extending the notion of environment to allow countably many variables to be bound in an environment. The higher-order procedure mem takes an admissibleprocedure and returns another procedure: if (eval e env) returns the admissible procedure (body, args, env2), then (eval '(mem e) env) returns the memoized procedure (mfun e , args, env+), where:</p><p xml:id="_XJsq7jn">• env+ is env2 (notionally) extended with a symbol V val , for each value val, bound to a value drawn from the distribution µ((e val), env).</p><p xml:id="_7vX2M9v">• mfun e is a new constant function such that mfun e applied to the environment env+ extended with args bound to val returns the value bound to V val .</p><p xml:id="_rKqQWkm">This definition implies that infinitely many random choices may be made when a memoized random procedure is created-the notion of admissibility must be extended to expressions which involve mem. In the next section we describe an appropriate extension of admissibility, such that admissible expressions still define a marginal distribution on values, and the conditional distributions defining query are well-formed.</p><p xml:id="_245BWHF">Ordinary memoization becomes a semantically meaningful construct within stochastic languages. This suggests that there may be useful generalizations of mem, which are not apparent in non-stochastic computation. Indeed, instead of always returning the initial value or always re-evaluating, one could stochastically decide on each evaluation whether to use a previously computed value or evaluate anew. We define such a stochastic memoizer DPmem by using the Dirichlet process (DP) <ref type="bibr" coords="3,359.33,723.10,20.02,8.74" target="#b19">[20]</ref>-a distribution on discrete distributions (define (DP alpha proc) (let ((sticks (mem (lambda x (beta 1.0 alpha)))) (atoms (mem (lambda x (proc))))) (lambda () (atoms (pick-a-stick sticks 1))))) (define (pick-a-stick sticks J) (if (&lt; (random) (sticks J)) J (pick-a-stick sticks (+ J 1))))</p><p xml:id="_rpaS4t7">(define (DPmem alpha proc) (let ((dps (mem (lambda args (DP alpha (lambda () (apply proc args))</p><p xml:id="_ar7XnwN">))))) (lambda argsin ((apply dps argsin))) )) built from an underlying base measure. For an admissible procedure e, the expression (DPmem a e) evaluates in env to a procedure which samples from a (fixed) sample from the DP with base measure µ(e, env) and concentration parameter a. (When a=0, DPmem reduces to mem, when a=∞, it reduces to the identity.) The notion of using the Dirichlet process to cache generative histories was first suggested in Johnson et al. <ref type="bibr" coords="4,63.38,400.31,10.00,8.74" target="#b4">[5]</ref>, in the context of grammar learning. In Fig. <ref type="figure" coords="4,292.17,400.31,5.08,8.74" target="#fig_1">2</ref> we write the Dirichlet Process and DPmem directly in Church, via a stick-breaking representation. This gives a definition of these objects, proves that they are semantically well-formed (provided the rest of the language is), and gives one possible implementation.</p><p xml:id="_peC3Ybm">We pause here to explain choices made in the language definition. Programs written with pure functions, those that always return the same value when applied to the same arguments, have a number of advantages. It is clear that a random function cannot be pure, yet there should be an appropriate generalization of purity which maintains some locality of information. We believe the right notion of purity in a stochastic language is exchangeability: if an expression is evaluated several times in the same environment, the distribution on return values is invariant to the order of evaluations. This exchangeability is exploited by the Metropolis-Hastings algorithm for approximating query given in Section 4.</p><p xml:id="_6Z5Hhu6">Mutable state (or an unpleasant, whole-program transformation into continuation passing style) is necessary to implement Church, both to model randomness and to implement mem using finite computation. However, this statefulness preserves exchangeability. Understanding the ways in which other stateful language constructs-in particular, primitives for the construction and modification of mutable statemight aid in the description of stochastic processes remains an important area for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2" xml:id="_xMRPCGM">Semantic Correctness</head><p xml:id="_bfcmnsd">In this section we give formal statements of the claims above, needed to specify the semantics of Church, and sketch their proofs. Let Church − denote the set of Church expressions that do not include mem. Proof sketch. Arrange the recursive calls to eval into a tree with an evaluation at each node and edges connecting successive applications of eval-if a node indicates the evaluation of an elementary random procedure there will be several edges descending from this node (one for each possible return value), and these edges are labeled with their probability. A history is a path from root to leaf in this tree and its probability is the product of the labels along the path. Let W n indicate the sum of probabilities of paths of length n or less. The claim is now that lim n→∞ W n converges and is bounded above by 1. The bound follows because the sum of labels below any random node is 1; convergence then follows from the monotone convergence theorem because the labels are non-negative.</p><p xml:id="_bBd8QXn">We next extend the notion of admissibility to arbitrary Church expressions involving mem. To compute the probability of an evaluation history we must include the probability of calls to mem-that is, the probability of drawing each return value V val . Because there are infinitely many V val , the probability of many histories will then be zero, therefore we pass to equivalence classes of histories. Two histories are equivalent if they are the same up to the values bound to V val -in particular they must evaluate all memoized procedures on the same arguments with the same return values. The probability of an equivalence class of histories is the marginal probability over all unused arguments and return values, and this is non-zero. The weight of an expression can now be defined as the sum over equivalence classes of finite histories.</p><p xml:id="_jny8Sts">Lemma 2.2. The admissibility of a Church expression in a given environment is well defined, and any expression e admissible in environment env defines a distribution µ(e, env) on return values of (eval 'e env).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head xml:id="_Pjq3mkc">Proof sketch:</head><p xml:id="_9B66JEm">The proof is by induction on the number of times mem is used. Take as base case expressions without mem; by Lemma 2.1 the weight is well defined, so the set of admissible expressions is also well defined.</p><p xml:id="_UjdQeBd">This function provides persistent class assignments to objects, where classes are symbols drawn from a pool with DP prior:</p><p xml:id="_htzgnHF">(define drawclass (DPmem 1.0 gensym)) (define class (mem (lambda (obj) (drawclass))))</p><p xml:id="_XeHFeCN">For the beta-binomial model there's a coin weight for each feature/class pair, and each object has features that depend only on it's type:</p><p xml:id="_3z33qy7">(define coin-weight (mem (lambda (feat obj-class) (beta 1 1))) ) (define value (mem (lambda (obj feat) (flip (coin-weight feat (class obj))) )))</p><p xml:id="_ZaPRV22">For a gaussian-mixture on continuous data (with known variance), we just change the code for generating values:</p><p xml:id="_u46RhDM">(define mean (mem (lambda (obj-class) (normal 0.0 10.0))) ) (define cont-value (mem (lambda (obj) (normal (mean (class obj)) 1.0) )))</p><p xml:id="_83xk8CP">The infinite relational model <ref type="bibr" coords="5,173.89,293.73,9.63,7.86" target="#b6">[7]</ref> with continuous data is similar, but means depend on classes of two objects:</p><p xml:id="_c9JUQ9k">(define irm-mean (mem (lambda (obj-class1 obj-class2) (normal 0.0 10.0) ))) (define irm-value (mem (lambda (obj1 obj2) (normal (irm-mean (class obj1) (class obj2)) 1.0 )))) Figure <ref type="figure" coords="5,94.40,391.52,3.66,7.86">3</ref>: Church expressions for infinite mixture type models, showing use of the random-world programming style in which objects have persistent properties. Functions beta and normal generate samples from these standard distributions. Now, assume p = (body, args, env) is an admissible procedure with well defined distribution on return values. The return from (mem p) is well defined, because the underlying measure µ(p, env) is well defined. It is then straightforward to show that any expression involving (mem p), but no other new memoized procedures, has a well defined weight. The induction step follows.</p><p xml:id="_FH8pvPP">A subtlety in this argument comes if one wishes to express recursive memoized functions such as:</p><p xml:id="_8w4yT8J">(define F (mem (lambda (x) (... F ...)))).</p><p xml:id="_3hTCPb6">Prima facie this recursion seems to eliminate the memoization-free base case. However, any recursive definition (or set of definitions) may be re-written without recursion in terms of a fixed-point combinator: (define F (fix ...)). With this replacement made we are reduced to the expected situation-application of fix may fail to halt, in which case F will be inadmissible, but the weight is well defined. Lemma 2.2 only applies to expressions involving mem for admissible procedures-a relaxation is possible for partially admissible procedures in some situations. From Lemma 2.2 it is straightforward to prove: Theorem 2.3. Assume expression e and procedure p are admissible in env, and let V be a random value distributed according to µ(e, env). If there exists a value v in the support of µ(e, env) and True has non-zero probability under µ((p v), env), then the conditional probability</p><formula xml:id="formula_2" coords="5,345.12,185.87,173.39,9.02">P (V =val | (eval '(p V ) env)=True)</formula><p xml:id="_YmrpU3m">is well defined.</p><p xml:id="_s66bWFm">Theorem 2.3 shows that query is a well-posed procedure; in Section 4 we turn to the technical challenge of actually implementing query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3" xml:id="_qM5tsqe">EXAMPLE PROGRAMS</head><p xml:id="_5aG2eJf">In this section we describe a number of example programs, stressing the ability of Church to express a range of standard generative models. As our first example, we describe diagnostic causal reasoning in a simple scenario: given that the grass is wet on a given day, did it rain (or did the sprinkler come on)? In outline of this might take the form of the query:</p><p xml:id="_fyfjEAv">(lex-query '((grass-is-wet ...) (rain ...) (sprinkler ...) '(rain 'day2) '(grass-is-wet 'day2) )</p><p xml:id="_xJrNBRz">where we define a causal model by defining functions that describe whether it rained, whether the sprinkler was on, and whether the grass is wet. The function grass-is-wet will depend on both rain and sprinkler-first we define a noisy-or function: Using this noisy-or function, and a look-up table for various weights, we can fill in the causal model:</p><p xml:id="_UVBZ794">(lex-query '((weight (lambda (ofwhat) (case ofwhat (('rain-str) 0.9) (('rain-prior) 0.3) ..etc..))) (grass-is-wet (mem (lambda (day) (noisy-or (rain day) (weight 'rain-str) (sprinkler day) (weight 'sprinkler-str) (weight 'grass-baserate)))))</p><p xml:id="_agzJ5Rb">This deterministic higher-order function defines the basic structure of stochastic transition models:</p><p xml:id="_Nr7tMZT">(define (unfold expander symbol) (if (terminal? symbol) symbol (map (lambda (x) (unfold expander x)) (expander symbol) )))</p><p xml:id="_sthekcC">A Church model for a PCFG transitions via a fixed multinomial over expansions for each symbol:</p><p xml:id="_6WwqnSC">(define (PCFG-productions symbol) (cond ((eq? symbol 'S) (multinomial '((S a) (T a)) '(0.2 0.8)) ) ((eq? symbol 'T) (multinomial '((T b) (a b)) '(0.3 0.7)) ))</p><p xml:id="_wzbwJxx">(define (sample-pcfg) (unfold PCFG-productions 'S))</p><p xml:id="_XmRrzwc">The HDP-HMM <ref type="bibr" coords="6,134.14,246.41,9.83,7.86" target="#b1">[2]</ref> uses memoized symbols for states and memoizes transitions:</p><p xml:id="_qg4t7mm">(define get-symbol (DPmem 1.0 gensym)) (define get-observation-model (mem (lambda (symbol) (make-100-sided-die)))) (define ihmm-transition (DPmem 1.0 (lambda (state) (if (flip) 'stop (get-symbol))</p><p xml:id="_C3Qk54c">(define (ihmm-expander symbol) (list ((get-observation-model symbol)) (ihmm-transition symbol) )) (define (sample-ihmm) (unfold ihmm-expander 'S))</p><p xml:id="_9TdpDhW">The HDP-PCFG <ref type="bibr" coords="6,380.49,109.43,9.73,7.86" target="#b7">[8]</ref> is also straightforward: Making adapted versions of any of these models <ref type="bibr" coords="6,517.48,248.90,9.83,7.86" target="#b4">[5]</ref> only requires stochastically memoizing unfold:</p><p xml:id="_XKr5SZY">(define adapted-unfold (DPmem 1.0 (lambda (expander symbol) (if (terminal? symbol) symbol (map (lambda (x) (adapted-unfold expander x)) (expander symbol) )))))</p><p xml:id="_5KQcR5d">Figure <ref type="figure" coords="6,215.32,360.88,3.58,7.86">4</ref>: Some examples of "stochastic transition models".</p><p xml:id="_BKTREtn">(rain (mem (lambda (day) (flip (weight 'rain-prior))))) (sprinkler (mem (lambda (day) (flip (weight 'sprinkler-prior)))))) '(rain 'day2) '(grass-is-wet 'day2) )</p><p xml:id="_MKPc8jX">Note that we have used mem to make the grass-is-wet, rain, and sprinkler functions persistent. For example, (= (rain 'day2) (rain 'day2)) is always True (it either rained on day two or not), this is necessary since both the query and predicate expressions will evaluate (rain 'day2).</p><p xml:id="_KD6HMKw">A Bayes net representation of this example would have clearly exposed the dependencies involved (though it would need to be supplemented with descriptions of the form of these dependencies). The Church representation, while more complex, lends itself to intuitive extensions that would be quite difficult in a Bayes net formulation. For instance, what if we don't know the Bernoulli weights, but we do have observations of other days? We can capture this by drawing the weights from a hyper-prior, redefining the weight function to:</p><p xml:id="_s3An8xQ">...(weight (mem (lambda (ofwhat) (beta 1 1))))... Going further, perhaps the probability of rain depends on (unknown) types of days (e.g. those with cumulus clouds, cirrus clouds, etc.), and perhaps the probability of the sprinkler activating depends on orthogonal types of days (e.g. Mondays and Fridays versus other days). We can model this scenario by drawing the prior probabilities from two stochastically memoized beta distributions: With this simple change we have extended the original causal model into an infinite mixture of such models, in which days are co-clustered into two sets of types, based on their relationship to the wetness of the grass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head xml:id="_CUWCHHH">If we now</head><p xml:id="_pf4bx8B">In the previous example we left the types of days implicit in the memoizer, using only the probability of rain or sprinkler. In Fig. <ref type="figure" coords="7,175.66,119.06,5.07,8.74">3</ref> we have given Church implementations for several infinite mixture models [see 7] using a different idiom-making the types into persistent properties of objects, drawn from an underlying memoized gensym (recall that gensym is simply a procedure which returns a unique value on each evaluation). Once we have defined the basic structure, class to draw latent classes for objects, it is straightforward to define the latent information for each class (e.g. coin-weight), and the observation model (e.g. value). This basic structure may be used to easily describe more complicated mixture models, such as the continuous-data infinite relational model (IRM) from <ref type="bibr" coords="7,117.10,274.47,9.98,8.74" target="#b6">[7]</ref>. Fig. <ref type="figure" coords="7,155.26,274.47,5.00,8.74">3</ref> describes forward sampling for these models; to describe a conditional model, these definitions must be made within the scope of a query. For instance, if we wished to query whether two objects have the same class, conditioned on observed features: Another idiom (Fig. <ref type="figure" coords="7,159.03,466.06,4.52,8.74">4</ref>) allows us to write the common class of "stochastic transition" models, which includes probabilistic context free grammars (PCFGs), hidden Markov models (HMMs), and their "infinite" analogs. Writing the HDP-PCFG <ref type="bibr" coords="7,212.91,513.88,10.52,8.74" target="#b7">[8]</ref> and HDP-HMM <ref type="bibr" coords="7,63.38,525.84,10.63,8.74" target="#b1">[2]</ref> in Church provides a compact and clear specification to these complicated non-parametric models. If we memoize unfold and use this adapted-unfold on PCFG transitions we recover the Adaptor Grammar model of <ref type="bibr" coords="7,104.83,573.66,10.06,8.74" target="#b4">[5]</ref>; if we similarly "adapt" the HDP-PCFG or HDP-HMM we get interesting new models that have not been considered in the literature.</p><p xml:id="_2fSXTs8">Fig. <ref type="figure" coords="7,83.64,615.50,4.50,8.74">5</ref>(top) gives an outline for using Church to represent planning problems. This is based on the translation of planning into inference, given in Toussaint et al. <ref type="bibr" coords="7,63.38,651.36,14.60,8.74" target="#b20">[21]</ref>, in which rewards are transformed into the probability of getting a single "ultimate reward". Inference on this representation results in decisions which softmaximizes the expected reward. Fig. <ref type="figure" coords="7,232.66,687.23,5.05,8.74">5</ref>(bottom) fills in this framework for a simple "red-light" game: the state is a light color (red/green) and an integer position, a "go" action advances one position forward (if (and (eq? light 'red-light) (flip cheat-det)) 0 (+ position 1)) position)))) (define (action-prior) (if (flip 0.5) 'go 'stop)) (define (sp1 state) (if (&gt; (last state) 5) 1 0))</p><p xml:id="_GVJBDa8">Figure <ref type="figure" coords="7,345.33,396.40,3.66,7.86">5</ref>: Top: The skeleton of planning-as-inference in Church (inspired by <ref type="bibr" coords="7,401.86,406.36,13.80,7.86" target="#b20">[21]</ref>). For simplicity, we assume an equal reward amount for each boolean "state property" that is true. Reward is given only when the state reaches a "terminal state", however the stochastic termination decision given by terminal? results in an infinite horizon with discount factor gamma. Bottom: A specific planning problem for the "red-light" game.</p><p xml:id="_4nWmVjJ">except that going on a red light results in being sent back to position 0 with probability cheat-det. The goal is to be past position 5 when the game ends; other rewards (e.g. for a staged game) could be added by adding sp2, sp3, and so on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4" xml:id="_ER2JAGB">CHURCH IMPLEMENTATION</head><p xml:id="_Sd6Dwfz">Implementing Church involves two complications beyond the implementation of eval as shown in Fig. <ref type="figure" coords="7,544.54,621.48,5.08,8.74">1</ref> (which is essentially the same as any lexically scoped, applicative order, pure Lisp <ref type="bibr" coords="7,437.05,645.39,10.19,8.74" target="#b5">[6]</ref>). First, we must find a way to implement mem without requiring infinite structures (such as the V val ). Second, we must implement query by devising a means to sample from the appropriate conditional distribution.</p><p xml:id="_mgz8Ewa">To implement mem we first note that the countably many V val are not all needed at once: they can be created as needed, extending the environment env+ when they are created. (Note that this implementation choices is stateful, but may be implemented easily in full Scheme: the argument/return value pairs can be stored in an association list which grows as need.) 4   We now turn to query. The sampling-based semantics of Church allows us to define a simple rejection sampler from the conditional distribution defining query; we may describe this as a Church expression:</p><p xml:id="_ETMWPSD">(define (query exp pred env) (let ((val (eval exp env)) (if (pred val) val (query exp pred env)))))</p><p xml:id="_HGeYbcM">The ability to write query as a Church programa metacircular <ref type="bibr" coords="8,132.46,441.42,10.63,8.74" target="#b0">[1]</ref> implementation-provides a compelling argument for Church's modeling power. However, exact sampling using this algorithm will often be intractable. It is straightforward to implement a collapsed rejection sampler that integrates out randomness in the predicate procedure (accepting or rejecting a val with probability equal to the marginal probability that (p val) is true). We show results in Fig. <ref type="figure" coords="8,280.95,525.11,4.88,8.74" target="#fig_8">6</ref> of this exact sampler used to query the infinite gaussianmixture model from Section 3.</p><p xml:id="_sBgrfme">In Fig. <ref type="figure" coords="8,96.60,566.95,5.07,8.74" target="#fig_10">7</ref> we show the result of running the collapsed rejection query for planning in the "red-light" game, as shown in Fig. <ref type="figure" coords="8,138.02,590.86,5.00,8.74">5</ref> (here gamma=0.2, cheat-det=0.7).</p><p xml:id="_UWREAwP">The result is intuitive: when position is near 0 there is little to lose by "cheating", as position nears 5 (the goal line) there is more to loose, hence the probability of cheating decreases; once past the goal line there is nothing to be gained by going, so the probability of cheating drops sharply. Note that the "soft-max" formulation of planning used here results in fairly random behavior even in extreme positions. 4 A further optimization implements DPmem via the Chinese restaurant process representation of the DP <ref type="bibr" coords="8,262.92,723.78,13.52,7.86" target="#b14">[15]</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1" xml:id="_qgTdrqr">A Metropolis-Hastings Algorithm</head><p xml:id="_bH654s5">We now present a Markov chain Monte Carlo algorithm for approximately implementing query, as we expect (even collapsed) rejection sampling to be intractable in general. Our algorithm executes stochastic local search over evaluation histories, making small changes by proposing changes to the return values of elementary random procedures. These changes are constrained to produce the conditioned result, collapsing out the predicate expression via its marginal probability 5 . The use of evaluation histories, rather than values alone, can be viewed as an extreme form of data-augmentation: all random choices that lead to a value are made explicit in its history.</p><p xml:id="_3gEXK6m">The key abstraction we use for MCMC is the computation trace. A computation trace is a directed, acyclic graph composed of two connected trees. The first is a tree of evaluations, where an evaluation node points to evaluation nodes for its recursive calls to eval. The second is a tree of environment extensions, where the node for an extended environment points to the node of the environment it extends. The evaluation node for each (eval 'e env) points to the environment node for env, and evaluation nodes producing values to be bound are pointed to by the environment extension of the binding. Traces are in one-to-one correspondence with equivalence classes of evaluation histories, described earlier 6 . Fig. <ref type="figure" coords="8,406.25,524.21,4.88,8.74" target="#fig_11">8</ref> shows the fragment of a computation trace for evaluation of the expression ((lambda (x) (+ x 3)) (flip)).</p><p xml:id="_K7KwX6G">For each elementary random procedure p we need a Markov chain transition kernel K p that proposes a new return value for that procedure given its current arguments. A generic such kernel comes from re- 5 Handling the rejection problem on chain initialization (and queries across deterministic programs, more generally) is a challenge. Replacing all language primitives (including if) with noisy alternatives and using tempering techniques provides one general solution, to be explored in future work. 6 Also note that the acyclicity of traces is a direct result of the purity of the Church language: if a symbol's value were mutated, its environment would point to the evaluation node that determined its new value, but that node would have been evaluated in the same environment. evaluating (eval '(p args) env); however, a proper Church standard library could frequently supply more efficient proposal kernels for particular procedures (for instance a drift kernel for normal). Our requirement is that we are able to sample a proposal from K p as well as evaluate its transition probability q p (•|•).</p><p xml:id="_mYp6WFZ">If we simply apply K p to a trace, the trace can become "inconsistent"-no longer representing a valid evaluation history from eval. To construct a complete Metropolis-Hastings proposal from K p , we must keep the computation trace consistent, and modify the proposal probabilities accordingly, by recursing along the trace updating values and potentially triggering new evaluations. For example, if we change the value of flip in (if (flip) e 1 e 2 ) from False to True we must: absorb the probability of (eval e 2 env) in the reverse proposal probability, evaluate e 1 and attach it to the trace, and include the probability of the resulting sub-trace in the forward proposal probability. (For a particular trace, the probability of the sub-trace for expression e is the probability of the equivalence class of evaluation histories corresponding to this subtrace.) The recursions for trace consistency and proposal computation are delicate but straightforward, and we omit the details due to space constraints<ref type="foot" coords="9,291.64,471.99,3.97,6.12" target="#foot_1">7</ref> . Each step of our MCMC algorithm<ref type="foot" coords="9,215.75,483.95,3.97,6.12" target="#foot_2">8</ref> consists of applying a kernel K p to the evaluations of a randomly chosen elementary random primitive in the trace, updating the trace to maintain consistency (collecting appropriate corrections to the proposal probability), and applying the Metropolis-Hastings criterion to accept or reject this proposal. (This algorithm ignores some details needed for queries containing nested queries, though we believe these to be straightforward.)</p><p xml:id="_hX53r4s">We have implemented and verified this algorithm on several examples that exercise all of the recursion and update logic of the system. In Fig. <ref type="figure" coords="9,222.40,623.01,5.08,8.74" target="#fig_13">9</ref> we have shown convergence results for this algorithm running on the simple "sprinkler" example of Section 3.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5" xml:id="_WRDdNAd">DISCUSSION</head><p xml:id="_MhxKjrs">While Church builds on many other attempts to marry probability theory with computation, it is distinct in several important ways. First, Church is founded on the lambda calculus, allowing it to represent higherorder logic and separating it from many related languages. For example, unlike several widely used languages grounded in propositional logic (e.g. BUGS <ref type="bibr" coords="9,535.56,376.40,10.67,8.74" target="#b8">[9]</ref>) and first-order logic (e.g. the logic programming approaches of <ref type="bibr" coords="9,370.67,400.31,15.61,8.74" target="#b12">[13,</ref><ref type="bibr" coords="9,390.93,400.31,11.71,8.74" target="#b18">19]</ref>, BLOG <ref type="bibr" coords="9,445.59,400.31,14.75,8.74" target="#b11">[12]</ref>, and Markov logic <ref type="bibr" coords="9,315.00,412.26,14.69,8.74" target="#b17">[18]</ref>), generative processes in Church are first-class objects that can be arbitrarily composed and abstracted. The example programs in Section 3 illustrate the representational flexibility of Church; while some of these programs may be naturally represented in one or another existing language, we believe that no other language can easily represent all of these examples.</p><p xml:id="_NJ4yTZT">The stochastic functional language IBAL <ref type="bibr" coords="9,501.67,501.92,14.74,8.74" target="#b13">[14]</ref>, based on the functional language ML, is quite similar to Church, but the two languages emphasize different aspects of functional programming. Other related work includes non-determistic <ref type="bibr" coords="9,450.04,549.75,15.58,8.74" target="#b10">[11]</ref> and weighted nondeterministic <ref type="bibr" coords="9,374.91,561.70,15.51,8.74" target="#b15">[16]</ref> extensions to Lisp. Unlike these approaches, the semantics of Church is fundamentally sampling-based: the denotation of admissible expressions as distributions follows from the semantics of evaluation rather than defining it. This semantics, combined with dynamic typing (cf. static typing of ML), permits the definition and exact implementation of query as an ordinary Church procedure, rather than a special transformation applied to the distribution denoted by a program. Because query is defined via sampling, describing approximate inference is particularly natural within Church.</p><p xml:id="_aUrDsJD">A number of the more unusual features of Church as a stochastic programming language derive from its ba-sis in Lisp. Since query and eval are the basic constructs defining the meaning of Church expressions, we have a metacircular <ref type="bibr" coords="10,152.66,89.17,15.53,8.74" target="#b16">[17]</ref> description of Church within Church. This provides clarity in reasoning about the language, and allows self-reflection within programs: queries may be nested within queries, and programs may reason about programs. Church expressions can serve both as a declarative notation for uncertain beliefs (via the distributions they represent) and as a procedural notation for stochastic and deterministic processes (via evaluation). Because expressions are themselves values, this generalizes the Lisp unification of programs and data to a unification of stochastic processes, Church expressions, and uncertain beliefs. These observations suggest exciting new modeling paradigms. For instance, eval nested within query may be used to learn programs, where the prior on programs is represented by another Church program. Issues of programming style then become issues of description length and inductive bias. As another example, query nested within query may be used to represent an agent reasoning about another agent.</p><p xml:id="_cpCzkzz">Of course, Church's representational flexibility comes at the cost of substantially increased inference complexity. Providing efficient implementations of query is a critical challenge as our current implementation is not yet efficient enough for typical machine learning applications; this may be greatly aided by building on techniques used for inference in other probabilistic languages [e.g. <ref type="bibr" coords="10,128.26,417.94,12.68,8.74" target="#b9">10,</ref><ref type="bibr" coords="10,144.06,417.94,12.68,8.74" target="#b13">14,</ref><ref type="bibr" coords="10,159.86,417.94,11.54,8.74" target="#b11">12]</ref>. For example, in Church, exact inference by enumeration could be seen as a program analysis that transforms expressions involving query into expressions involving only eval; identifying and exploiting opportunities for such transformations seems appealing. Probabilistic models and stochastic algorithms are finding increasingly widespread use throughout artificial intelligence and cognitive science, central to areas as diverse as vision, planning, and natural language understanding. As their usage grows and becomes more intricate, so does the need for formal languages supporting model exchange, reuse, and machine execution. We hope Church represents a significant step toward this goal.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0" coords="1,315.00,653.12,149.96,8.74;1,315.00,673.16,235.29,9.65;1,392.90,688.11,172.28,9.65"><head></head><label></label><figDesc xml:id="_4qHkV86">Church expressions have the form: expression ::= c | x | (e 1 e 2 ...) | (lambda (x...) e) | (if e 1 e 2 e 3 ) | (define x e) | (quote e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1" coords="4,63.38,228.38,234.90,7.86;4,63.14,238.34,233.86,8.11;4,63.38,248.30,233.62,8.11;4,61.97,258.91,95.03,7.47"><head>Figure 2 :</head><label>2</label><figDesc xml:id="_h784e8b">Figure 2: Church implementation of the Dirichlet Process, via stick breaking, and DPmem. (Evaluating (apply proc args) in env for args=(a1 ...) is equivalent to (eval '(proc a1 ...) env).)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2" coords="4,315.00,188.31,122.49,8.77;4,437.49,186.76,6.23,6.12;4,447.89,188.34,100.73,9.02;4,315.00,200.29,194.61,8.74"><head>Lemma 2 . 1 .</head><label>21</label><figDesc xml:id="_pdagv5Q">If e ∈ Church − then the weight of e in a given environment is well-defined and ≤ 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3" coords="5,315.00,539.78,240.08,7.47;5,324.42,549.74,131.81,7.47;5,343.24,559.71,112.98,7.47;5,343.24,569.67,80.02,7.47"><head>(</head><label></label><figDesc xml:id="_XT6Ddtx">define (noisy-or a astrength b bstrength baserate) (or (and (flip astrength) a) (and (flip bstrength) b) (flip baserate)))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4" coords="6,314.93,125.02,61.19,7.47;6,404.37,125.02,70.61,7.47;6,314.46,134.98,160.05,7.47;6,314.46,144.94,80.02,7.47;6,324.35,154.90,94.15,7.47;6,357.30,164.87,193.00,7.47;6,314.46,174.83,103.56,7.47;6,324.35,184.79,47.07,7.47;6,357.30,194.75,75.32,7.47;6,366.71,204.72,178.88,7.47;6,385.54,214.68,141.22,7.47;6,385.54,224.64,160.05,7.47;6,314.46,234.60,235.37,7.47"><head></head><label></label><figDesc xml:id="_ApeQ8sZ">-probs '(.1 .2 .2 .5)) (define rule-type (mem (lambda symbol) (if (flip) 'terminal 'binary-production)) (define ipcfg-expander (DPmem 1.0 (lambda (symbol) (if (eq? (rule-type symbol) 'terminal) (multinomial terms term-probs) (list (get-symbol) (get-symbol)))) (define (sample-ipcfg) (unfold ipcfg-expander 'S))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5" coords="6,315.00,600.15,47.07,7.47;6,319.71,610.12,75.32,7.47;6,338.54,620.08,164.76,7.47;6,329.12,630.04,89.44,7.47;6,338.54,640.00,164.76,7.47;6,329.12,649.97,112.98,7.47;6,338.54,659.93,117.68,7.47;6,329.12,669.89,136.51,7.47;6,338.54,679.85,145.93,7.47;6,324.42,689.82,18.83,7.47"><head>(</head><label></label><figDesc xml:id="_cXz3SYa">lex-query '((new-rain-prob (DPmem 1.0 (lambda () (beta 1 1)))) (new-sprinkler-prob (DPmem 1.0 (lambda () (beta 1 1)))) (rain (mem (lambda (day) (flip (new-rain-prob))))) (sprinkler (mem (lambda (day) (flip (new-sprinkler-prob)))))) ...)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6" coords="7,63.38,355.65,47.07,7.47;7,68.09,365.61,141.22,7.47;7,77.50,375.58,51.78,7.47;7,77.50,385.54,80.02,7.47;7,77.50,395.50,56.49,7.47;7,68.09,405.47,150.64,7.47;7,68.09,415.43,23.54,7.47;7,82.21,425.39,127.10,7.47;7,82.21,435.35,117.68,7.47;7,82.21,445.32,127.10,7.47"><head>(</head><label></label><figDesc xml:id="_ZTt5qys">lex-query '((drawclass (mem 1.0 gensym)) (class ...) (coin-weight ...) (value ...)) '(= (class 'alice) (class 'bob)) '(and (= (value 'alice 'blond) 1) (= (value 'bob 'blond) 1) (= (value 'jim 'blond) 0)))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7" coords="7,315.00,65.24,155.34,7.47;7,324.42,75.20,23.54,7.47;7,333.83,85.16,131.81,7.47;7,333.83,95.13,80.02,7.47;7,314.53,105.09,188.29,7.47;7,314.53,115.05,136.51,7.47;7,324.42,125.02,207.12,7.47;7,314.53,134.98,47.07,7.47;7,324.42,144.94,145.93,7.47;7,333.83,154.90,56.49,7.47;7,343.24,164.87,117.68,7.47;7,352.66,174.83,164.76,7.47;7,333.83,184.79,56.49,7.47;7,343.24,194.75,108.27,7.47;7,371.49,204.72,80.02,7.47;7,371.49,214.68,47.07,7.47;7,324.42,224.64,61.20,7.47;7,324.42,234.60,127.10,7.47;7,315.00,253.18,127.10,7.47;7,324.42,263.15,23.54,7.47;7,333.83,273.11,183.59,7.47;7,333.83,283.07,155.34,7.47;7,366.78,293.04,136.51,7.47;7,366.78,303.00,94.15,7.47;7,343.24,312.96,94.15,7.47"><head>(</head><label></label><figDesc xml:id="_qbfNzrk">define (transition state-action) (pair (forward-model state-action) (action-prior) )) (define (terminal? symbol) (flip gamma)) (define (reward-pred rewards) (flip ((/ (sum rewards) (length rewards))))) (lex-query '((first-action (action-prior)) (final-state (first (unfold transition (pair start-state first-action) ))) (reward-list (list (sp1 final-state) (sp2 final-state) ..etc.. )) 'first-action '(reward-pred reward-list)) (define (forward-model s-a) (pair (if (flip 0.5) 'red-light 'green-light) (let ((light (first (first s-a))) (position (last (first s-a))) (action (last s-a))) (if (eq? action 'go)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8" coords="8,213.85,72.38,77.44,7.86;8,213.85,82.34,70.25,7.86;8,213.85,92.30,69.50,7.86;8,213.85,102.26,73.80,7.86;8,213.85,112.23,67.08,7.86;8,213.85,122.19,75.33,7.86;8,213.85,132.15,78.56,7.86;8,213.85,142.11,73.29,7.86;8,213.85,152.08,72.75,8.12;8,213.85,162.04,74.47,7.86;8,213.85,172.00,77.50,7.86;8,213.85,181.96,66.84,7.86;8,213.85,191.93,79.70,7.86;8,213.85,201.89,49.73,7.86"><head>Figure 6</head><label>6</label><figDesc xml:id="_rdW6rRD">Figure 6: Posterior samples from the infinite gaussianmixture (with unknown variance) of Section 3, using the collapsed rejection algorithm for query. Two datasets are shown (as dots) with mixture components and posterior predictive distribution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9" coords="8,329.21,151.55,2.45,4.36;8,347.46,151.55,2.45,4.36;8,365.74,151.55,2.45,4.36;8,383.99,151.55,2.45,4.36;8,402.27,151.55,2.45,4.36;8,420.52,151.55,2.45,4.36;8,438.79,151.55,2.45,4.36;8,321.13,136.09,8.59,4.36;8,323.59,123.91,6.13,4.36;8,321.13,111.73,8.59,4.36;8,323.59,99.57,6.13,4.36;8,321.13,87.39,8.59,4.36;8,323.59,75.21,6.13,4.36;8,321.13,63.05,8.59,4.36;8,376.59,156.04,17.45,4.48;8,315.38,119.89,4.54,22.59;8,315.38,114.51,4.54,4.04;8,315.38,96.48,4.54,16.68;8,315.38,82.23,4.54,12.91;8,315.38,72.01,4.54,8.88"><head></head><label></label><figDesc xml:id="_6thaJ4u">action 'go'.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10" coords="8,453.52,72.50,92.55,7.86;8,453.52,82.46,86.53,7.86;8,453.52,92.42,84.55,7.86;8,453.52,102.38,95.49,7.86;8,453.52,112.35,82.92,7.86;8,453.18,122.31,88.35,7.86;8,453.28,132.27,83.86,7.86;8,453.52,142.23,95.13,7.86;8,453.52,152.20,62.31,7.86"><head>Figure 7 :</head><label>7</label><figDesc xml:id="_vD6hUvP">Figure7: Results from planning in the "redlight" game (Fig.5), showing the probability of "cheating" (going when the light is red) versus position. The goal is to end the game past position 5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11" coords="9,95.73,144.91,168.92,7.86"><head>Figure 8 :</head><label>8</label><figDesc xml:id="_nd9WcW6">Figure 8: A schematic computation trace.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13" coords="9,465.47,67.92,72.54,7.86;9,465.47,77.88,67.48,7.86;9,465.47,87.84,71.09,7.86;9,465.47,97.80,61.53,7.86;9,463.17,107.77,73.15,7.86;9,465.47,117.73,73.95,7.86;9,465.47,127.69,65.05,7.86;9,465.24,137.65,73.10,7.86;9,465.14,147.62,79.01,7.86;9,465.47,157.58,68.37,8.11;9,465.47,167.54,78.20,7.86;9,465.23,177.51,77.24,8.12;9,465.00,188.11,59.10,7.47;9,465.47,197.43,68.41,7.86;9,465.47,207.39,77.96,7.86;9,465.47,217.36,80.82,7.86;9,465.47,227.32,83.12,7.86;9,465.47,237.28,81.48,7.86;9,465.47,247.24,63.04,7.86"><head>Figure 9 :</head><label>9</label><figDesc xml:id="_anDPgSG">Figure 9: Convergence of one run of the MCMC algorithm on the "sprinkler" example. (Each sample from query uses 30 MCMC steps.) Top: The probability of rain. Bottom: The expected value of (+ (rain) (sprinkler)), showing explaining away. The sum is slightly above 1.0 because one cause is usually present, but both rarely are.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" coords="6,63.38,404.37,378.72,327.47"><head></head><label></label><figDesc xml:id="_MJgFkBG">query conditioned on observations from other days, we implicitly learn the weight parameters of the model:</figDesc><table coords="6,315.00,404.37,127.10,77.21"><row><cell>(lex-query</cell></row><row><cell>'...model definitions...</cell></row><row><cell>'(rain 'day2)</cell></row><row><cell>'(and</cell></row><row><cell>(grass-is-wet 'day1)</cell></row><row><cell>(rain 'day1)</cell></row><row><cell>(not (sprinkler 'day1))</cell></row><row><cell>(grass-is-wet 'day2)) )</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_0">However, if evaluating an elementary random procedure results in evaluating another elementary random procedure we take only the probability of the first, since it already includes the second.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_1">We implemented our MCMC algorithm atop the Blaise system<ref type="bibr" coords="9,93.81,683.24,9.19,7.86" target="#b2">[3]</ref>, which simplifies these recursively triggered kernel compositions.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_2"><ref type="bibr" coords="9,75.82,702.08,3.65,5.24" target="#b7">8</ref> At the time of writing we have not implemented this algorithm for programs that use mem, though we believe the necessary additions to be straightforward.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head xml:id="_dwcsutP">Acknowledgements</head><p xml:id="_ZC3j5HT">The authors would like to thank Gerry Sussman, Hal Abelson, Tom Knight, Brian Milch, David McAllester and Alexey Radul for helpful discussions. This work was funded in part by a grant from NTT Communication Sciences Laboratory.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct coords="10,334.32,81.88,215.29,7.86;10,334.32,91.84,194.11,7.86" xml:id="b0">
	<monogr>
		<title level="m" type="main" xml:id="_sFyVAjw">Structure and Interpretation of Computer Programs</title>
		<author>
			<persName coords=""><forename type="first">H</forename><surname>Abelson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">G</forename><surname>Sussman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,103.80,214.31,7.86;10,334.32,113.76,187.10,7.86" xml:id="b1">
	<monogr>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">J</forename><surname>Beal</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Z</forename><surname>Ghahramani</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">C</forename><forename type="middle">E</forename><surname>Rasmussen</surname></persName>
		</author>
		<title level="m" xml:id="_py2y6Mk">The infinite hidden Markov model</title>
				<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="volume">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,125.71,214.30,7.86;10,334.32,135.68,150.28,8.37" xml:id="b2">
	<monogr>
		<title level="m" type="main" xml:id="_R7zgcAK">Composable Probabilistic Inference with Blaise</title>
		<author>
			<persName coords=""><forename type="first">K</forename><forename type="middle">A</forename><surname>Bonawitz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>MIT</publisher>
		</imprint>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct coords="10,334.32,147.63,214.31,7.86;10,334.32,157.59,215.59,7.86;10,333.86,167.56,20.99,7.86" xml:id="b3">
	<analytic>
		<title level="a" type="main" xml:id="_MGCjV5F">A Set of Postulates for the Foundation of Logic</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" xml:id="_PtdzU7Y">The Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="346" to="366" />
			<date type="published" when="1932">1932</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,179.51,214.49,7.86;10,334.32,189.48,214.30,7.86;10,334.32,199.44,195.79,7.86" xml:id="b4">
	<monogr>
		<title level="m" type="main" xml:id="_mDyFkwW">Adaptor grammars: A framework for specifying compositional nonparametric Bayesian models. NIPS 19</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Goldwater</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,211.39,210.34,7.86;10,544.65,209.63,3.65,5.24;10,334.32,221.36,215.29,7.86;10,333.61,231.32,213.63,7.86" xml:id="b5">
	<monogr>
		<title level="m" xml:id="_5wexvqr">Revised 5 Report on the Algorithmic Language Scheme. Higher-Order and Symbolic Computation</title>
				<editor>
			<persName><forename type="first">R</forename><surname>Kelsey</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><surname>Clinger</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Rees</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="7" to="105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,243.27,215.84,7.86;10,334.32,253.24,214.31,7.86;10,333.99,263.20,214.63,7.86;10,333.66,273.16,156.25,7.86" xml:id="b6">
	<analytic>
		<title level="a" type="main" xml:id="_TcMmuBX">Learning systems of concepts with an infinite relational model</title>
		<author>
			<persName coords=""><forename type="first">C</forename><surname>Kemp</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">T</forename><forename type="middle">L</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">N</forename><surname>Ueda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_TwkT8DA">Proc. 21st Natl Conf</title>
				<meeting>21st Natl Conf</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,285.12,214.31,7.86;10,334.32,295.08,216.09,7.86;10,334.01,305.04,117.19,7.86" xml:id="b7">
	<monogr>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Petrov</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
		<title level="m" xml:id="_4F6KjfN">The Infinite PCFG using Hierarchical Dirichlet Processes. Proc. EMNLP-CoNLL</title>
				<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,317.00,215.85,7.86;10,334.32,326.96,215.59,7.86;10,334.32,336.92,214.31,7.86;10,333.66,346.88,131.81,7.86" xml:id="b8">
	<analytic>
		<author>
			<persName coords=""><forename type="first">D</forename><forename type="middle">J</forename><surname>Lunn</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">N</forename><surname>Best</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Spiegelhalter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_8BmCauy">WinBUGS-A Bayesian modelling framework: Concepts, structure, and extensibility</title>
				<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="325" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,358.84,216.09,7.86;10,334.32,368.80,215.85,7.86;10,334.32,378.77,214.55,7.86;10,334.32,388.73,214.31,7.86;10,333.99,398.69,71.17,7.86" xml:id="b9">
	<monogr>
		<title level="m" type="main" xml:id="_GBdcCcs">Random-world semantics and syntactic independence for expressive languages</title>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Mcallester</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Milch</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">N</forename><forename type="middle">D</forename><surname>Goodman</surname></persName>
		</author>
		<idno>MIT-CSAIL-TR-2008-025</idno>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Massachusetts Institute of Technology</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct coords="10,334.32,410.65,214.30,7.86;10,334.32,420.61,214.31,7.86;10,334.06,430.57,112.43,7.86" xml:id="b10">
	<analytic>
		<title level="a" type="main" xml:id="_sUVdjGH">A Basis for a Mathematical Theory of Computation</title>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_SUgkcZA">Computer Programming and Formal Systems</title>
				<imprint>
			<date type="published" when="1963">1963</date>
			<biblScope unit="page" from="33" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,442.53,215.59,7.86;10,334.32,452.49,214.30,7.86;10,334.32,462.45,150.75,7.86" xml:id="b11">
	<analytic>
		<title level="a" type="main" xml:id="_erdnbZJ">BLOG: Probabilistic models with unknown objects</title>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Milch</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">B</forename><surname>Marthi</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><surname>Sontag</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">D</forename><forename type="middle">L</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Kolobov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_AYAfP5f">Proc. IJCAI</title>
				<meeting>IJCAI</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,474.41,214.31,7.86;10,334.32,484.37,215.30,7.86;10,334.32,494.33,174.85,7.86" xml:id="b12">
	<analytic>
		<title level="a" type="main" xml:id="_ku2bCG9">Stochastic logic programs</title>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Muggleton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_bVPZ8xz">Advances in Inductive Logic Programming</title>
				<editor>
			<persName><forename type="first">L</forename><surname>De Raedt</surname></persName>
		</editor>
		<imprint>
			<publisher>IOS Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="254" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,506.29,215.85,7.86;10,334.32,516.25,141.23,7.86" xml:id="b13">
	<analytic>
		<title level="a" type="main" xml:id="_jSatgMV">IBAL: A probabilistic rational programming language</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Pfeffer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_tD3DYM7">Proc. IJCAI</title>
				<meeting>IJCAI</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,528.20,216.09,7.86;10,334.32,538.17,153.84,7.86" xml:id="b14">
	<analytic>
		<title level="a" type="main" xml:id="_hvsN6eE">Combinatorial stochastic processes</title>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Pitman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s" xml:id="_EGnQeK9">Notes for Saint Flour Summer School</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,550.12,214.31,7.86;10,334.32,560.09,215.59,7.86;10,334.32,570.05,179.71,7.86" xml:id="b15">
	<monogr>
		<title level="m" type="main" xml:id="_xAE4eX7">Report on the probabilistic language scheme</title>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Radul</surname></persName>
		</author>
		<idno>MIT-CSAIL-TR-2007-059</idno>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct coords="10,334.32,582.00,215.85,7.86;10,334.32,591.97,214.30,7.86;10,334.09,601.93,58.87,7.86" xml:id="b16">
	<analytic>
		<title level="a" type="main" xml:id="_rRyKxnW">Definitional interpreters for higherorder programming</title>
		<author>
			<persName coords=""><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_sW63wjQ">ACM Annual Conference</title>
				<imprint>
			<date type="published" when="1972">1972</date>
			<biblScope unit="page" from="717" to="740" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,613.88,215.84,7.86;10,333.99,623.85,190.29,7.86" xml:id="b17">
	<analytic>
		<title level="a" type="main" xml:id="_k5GU54U">Markov logic networks</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">P</forename><surname>Domingos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_HfFSjxG">Machine Learning</title>
				<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="107" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,635.80,215.85,7.86;10,334.32,645.76,214.31,7.86;10,333.66,655.73,172.04,7.86" xml:id="b18">
	<analytic>
		<title level="a" type="main" xml:id="_ehHcSMx">PRISM: A symbolicstatistical modeling language</title>
		<author>
			<persName coords=""><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">Y</forename><surname>Kameya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m" xml:id="_xSCUuSu">International Joint Conference on Artificial Intelligence</title>
				<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,667.68,214.56,7.86;10,334.32,677.64,131.33,7.86" xml:id="b19">
	<analytic>
		<title level="a" type="main" xml:id="_FxVE6vW">A Constructive definition of Dirichlet priors</title>
		<author>
			<persName coords=""><forename type="first">J</forename><surname>Sethuraman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j" xml:id="_Wk5wZJN">Statistica Sinica</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct coords="10,334.32,689.60,215.84,7.86;10,334.32,699.56,214.31,7.86;10,334.32,709.52,215.58,7.86;10,334.09,719.49,20.99,7.86" xml:id="b20">
	<monogr>
		<title level="m" type="main" xml:id="_3d6tUj9">Probabilistic inference for solving (PO)MDPs</title>
		<author>
			<persName coords=""><forename type="first">M</forename><surname>Toussaint</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">S</forename><surname>Harmeling</surname></persName>
		</author>
		<author>
			<persName coords=""><forename type="first">A</forename><surname>Storkey</surname></persName>
		</author>
		<idno>EDI-INF-RR-0934</idno>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
